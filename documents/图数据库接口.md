## 接口说明
1. 接口所有**字符串**的入参以及回调都需要进行Base64编码
## 查询

### 实体查询接口（关键字检索）

1. 根据关键字检索实体，返回匹配实体的列表
2. 实体的查询根据NAME匹配>OTHER_NAME匹配>ENCY_CONTENT匹配
3. 返回查询的列表，按照2的顺序排列
4. 入参

| key | 字段说明 | 类型 | 可否为空 |
|:---:|:---:|:---:|:---:|
| search_name | 检索的实体名字 | string | N |
5. 回调

| key | 字段说明 | 类型 | 可否为空 |
|:---:|:---:|:---:|:---:|
| search_res | 检索结果 | list/array | N |

6. 当没搜索到直接返回[]（空数组）
7. 对数组里面的每一个元素进行Base64编码
8. 检索到之后数组里面是json
    1. index从1开始，用数字表示
    2. image可选，有就写，没有就不写，虽然说现在应该是都没有
```json
{
    "name":"实体名字",
    "abstract":"实体简介",
    "index":1,
    "image":""
}
```

### 两个实体之间的关系查询接口

1. 检索两个实体，查找两个实体的关系
2. 返回两个实体的关系，如果实体之间没有关系，则has_link=false
3. 入参
    + 关系的查询方式有
        1. 最短关系，method="1"
        2. 最长关系，method="2"
        3. 最短的十条关系，method="3"

| key | 字段说明 | 类型 | 可否为空 |
|:---:|:---:|:---:|:---:|
| from_entity_name | 从何处出发检索的实体名字 | string | N |
| to_entity_name | 从何处出发检索的实体名字 | string | N |
| method | 关系的查询方式 | string | N |
4. 回调

| key | 字段说明 | 类型 | 可否为空 |
|:---:|:---:|:---:|:---:|
| has_link | 是否存在关系 | bool | N |
| links_content | 关系文本 | string | N |

5. 关系文本格式样例
    1. 这个是a-d之间的关系
    ```txt
        [[a]]--[[b]]=朋友={{连接关系|a不知道和b有啥关系，但是就是有关系}}=AI
        [[b]]--[[c]]=朋友={{连接关系|b不知道和c有啥关系，但是就是有关系}}
        [[d]]--[[c]]=朋友={{连接关系|c不知道和d有啥关系，但是就是有关系}}=AI
    ```
    2. 当然a-d之间的关系不止一条的话也是可以的
        1. 需要注意返回的文本，应该优先处理所有与主节点相关的节点信息
        2. 当作为两个节点的关系时，则优先处理from，然后是to的
        3. （其实不遵守也不会错，就是前端的节点标签是创建的时候就加入且之后不会改，优先处理主节点节点与主节点的关系就应该不怎么会错）
    ```txt
        [[a]]--[[b]]=朋友={{连接关系|a不知道和b有啥关系，但是就是有关系}}=AI
        [[a]]--[[e]]=朋友={{连接关系|a不知道和e有啥关系，但是就是有关系}}=AI
        [[d]]--[[c]]=朋友={{连接关系|c不知道和d有啥关系，但是就是有关系}}=AI
        [[d]]--[[e]]=朋友={{连接关系|e不知道和d有啥关系，但是就是有关系}}=AI
        [[b]]--[[c]]=朋友={{连接关系|b不知道和c有啥关系，但是就是有关系}}
    ```


### 获取详细实体信息接口

1. 查找实体，返回实体的详细信息，不存在则has_entity=false
2. 入参

| key | 字段说明 | 类型 | 可否为空 |
|:---:|:---:|:---:|:---:|
| entity_id | 实体id | string | N |

3. 回调

| key | 字段说明 | 类型 | 可否为空 |
|:---:|:---:|:---:|:---:|
| has_entity | 实体是否存在 | bool | N |
| name | 实体名字 | string | N |
| ency_content | 实体百科文档 | string | N |
| map_content | 实体图文档 | string | N |

### 实体识别接口

1. 传入一段文字，在里面查找实体，给实体打上标签（看示例）
2. 入参

| key | 字段说明 | 类型 | 可否为空 |
|:---:|:---:|:---:|:---:|
| content | 待处理文本 | string | N |

3. 回调

| key | 字段说明 | 类型 | 可否为空 |
|:---:|:---:|:---:|:---:|
| content | 处理完的文本 | string | N |

4. 示例
    1. 例如数据库有实体：苹果、香蕉、西瓜
    2. 输入文本是：我爱吃苹果和香蕉，不爱吃西瓜和橘子。
    3. 返回文本应该是：我爱吃[[苹果]]和[[香蕉]]，不爱吃[[西瓜]]和橘子。
    4. 这部分看源码！！！应该是这个格式和md的标记有冲突，所以渲染之后的符号消失了

### 实体概要信息返回接口 【做的时候详细确定】

1. 检索实体，返回实体的概要信息，不存在has_entity=false
2. 实体有一个属性专门存储概要信息
3. 入参

| key | 字段说明 | 类型 | 可否为空 |
|:---:|:---:|:---:|:---:|
| entity_name | 实体名字 | string | N |

4. 回调

| key | 字段说明 | 类型 | 可否为空 |
|:---:|:---:|:---:|:---:|
| has_entity | 实体是否存在 | bool | N |
| name | 实体名字 | string | N |
| abstract | 概要信息 | string | N |

### 返回所有实体列表（概览操作） 【待定】

1. 传入查询的标签条件，返回实体列表，里面有实体的名称和标签

## 对话

1. 入参：数组，每个元素都是一个json格式，包括content和role

| key | 字段说明 | 类型 | 可否为空 |
|:---:|:---:|:---:|:---:|
| content | 问题文本 | string | N |
| role | 用户/AI | string | N |
2. 回调

| key | 字段说明 | 类型 | 可否为空 |
|:---:|:---:|:---:|:---:|
| success | 结果 | string | N |
| answer | 回答文本 | string | N |

### 对话发送接口

## 译码器

### mapToCql（名字你可以自己取）
1. 功能
    1. 将文本内容转换成可以进行存储关系需要的参数等
2. 入参 string类型字符串
    1. 示例，输入:
        1. ``` [[a]]--[[b]]=朋友={{连接关系|a不知道和b有啥关系，但是就是有关系}}=AI ```
        2. ``` [[a]]--[[b]]=朋友={{连接关系|a不知道和b有啥关系，但是就是有关系}} ```
    2. 解释
        1. ```[[a]]对应一个实体，NAME=a```
        2. ```[[b]]对应一个实体，NAME=b```
        3. ```朋友 代表a和b的关系，请注意是a单向到b的关系```
        4. ```{{连接关系|a不知道和b有啥关系，但是就是有关系}} 代表a、b关系的具体描述```
        5. ```AI 代表这段信息是否是AI生成且没有人工查验的 存在代表是AI且没有查验 不存在代表人工已经查验```
    3. 假定字符串一定是这样的格式的

### cqlToMap（名字你可以自己取）
1. 功能
    1. 将关系导出成前端可渲染的文本
2. mapToCql的逆向